<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<script>
    // 生成随机整数的数组
    function setArray(num) {
        let arr = []
        for (let i = 0; i < num; i++) {
            arr[i] = Math.floor(Math.random() * (num + 1))
        }
        return arr   // 返回1~num的整数
    }

    function toString(arr) {
        let restr = ""
        for (let i = 0; i < arr.length; i++) {
            restr += arr[i] + " "
            if (i > 0 && i % 10 == 0) {
                restr += "\n"
            }
        }
        return restr
    }

    function swap(arr, index1, index2) {
        let temp = arr[index]
        arr[index1] = arr[index2]
        arr[index2] = temp
    }

    // 1.基本排序算法
    // 冒泡排序
    {
        // 冒泡排序,最慢的排序算法之一,也是最容易实现的排序算法
        function bubbleSort(array) {
            let length = array.length
            let temp = ""
            for (let i = length - 1; 0 < i; i--) {
                for (let j = 0; j < i; j++) {
                    if (array[j] > array[j + 1]) {
                        temp = array[j]
                        array[j] = array[j + 1]
                        array[j + 1] = temp
                    }
                }
            }
            return array
        }

        // 使用bubbleSort()对10个数字排序
    }
    // 选择排序
    {
        // 找到数组最小的元素，将它和数组红第一个元素交换位置，接下来，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置，往复如此，直到将整个数组排序。基本点就是不断地选择剩余元素之中的最小者。
        /*
            特点:
                运行时间和输入无关。
                对于长度为N的数组，选择排序需要大约N^2/2次比较和N次交换

                数据移动是最少的
                交换次数和数组的大小是线性关系。
         */
        function selectionSort(array) {
            let len = array.length
            for (let i = 0; i < len - 1; i++) {  //这里之所以是len-1，是因为到最后两个元素，交换位置，整个数组就已经排好序了。
                let minnum = array[i]
                for (let j = i + 1; j < len; j++) { // j=i+1是把与自己比较的情况给省略掉
                    if (array[j] < minnum) {
                        let c
                        c = minnum
                        minnum = array[j]    //交换两个值
                        array[j] = c
                    }
                }
                array[i] = minnum
            }
            return array
        }

        let arr1 = setArray(10)
        let sort = selectionSort(arr1)
        console.log('原数组', arr1, '选择排序', sort)
    }

    // 插入排序
    {
        // 从第一个元素开始，该元素可以认为已经被排序
        // 取出下一个元素，在已经排序的元素序列中从后向前扫描
        // 如果该元素（已排序）大于新元素，将该元素移到下一位置
        // 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置
        // 将新元素插入到该位置后
        // 重复步骤 2~5
        function insertionSort(array) {
            function swap(array, i, j) {
                let temp = array[i]
                array[i] = array[j]
                array[j] = temp
            }
            let length = array.length,
                i,
                j
            for (i = 1; i < length; i++) {
                for (j = i; j > 0; j--) {
                    if (array[j - 1] > array[j]) {
                        swap(array, j - 1, j)
                    } else {
                        break
                    }
                }
            }
            return array
        }
        // 创建一个随机数组
        let arr1 = []
        for (let i = 0; i < 10; i++) {
            arr1[i] = Math.floor(Math.random() * 100 + 1)  // 1~100的整数
        }
        console.log('快排', '原数组', arr1, '插入排序后', insertionSort(arr1))
    }
    // 基本排序算法的计时比较
    // 2.高级排序算法
    // 希尔排序
    // 归并排序
    // 快速排序
    {
        function quickSort(list) {
            if (list.length === 0) {
                return []
            }
            let lesser = []
            let greater = []
            let base = list[0]
            for (let i = 1; i < list.length; i++) {
                if (list[i] < base) {
                    lesser.push(list[i])
                } else {
                    greater.push(list[i])
                }
            }
            return quickSort(lesser).concat(base, quickSort(greater))
        }

        // 创建一个随机数组
        let arr1 = []
        for (let i = 0; i < 10; i++) {
            arr1[i] = Math.floor(Math.random() * 100 + 1)  // 1~100的整数
        }
        console.log('快排', '原数组', arr1, '快排后', quickSort(arr1))
    }
</script>
</body>
</html>