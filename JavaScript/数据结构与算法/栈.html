<!doctype html>
<html lang="zh-Hans">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>栈</title>
</head>
<body>
<script>
    // 1.栈
    // 栈是一种和列表类似的一种数据结构,是一种高效的数据结构,因为只能在栈顶添加或删除,所以操作很快,容易实现.
    // 栈顶:栈是一种特殊的列表,栈内的元素只能通过列表的一端访问,这一端称为栈顶.
    // 栈被称为一种后入先出(LIFO, last-in-first-out)的数据结构
    // 对栈的两种主要操作:1.将一个元素压入栈和将一个元素弹出栈.2.预览栈顶的元素.

    // 2.栈的实现

    function Stack() {
        this.dataStore = []
        this.top = 0
        this.push = push
        this.pop = pop
        this.peek = peek
        this.clear = clear
        this.length = length
    }

    function push(element) {
        this.dataStore[this.top++] = element
    }

    function peek() {
        return this.dataStore[this.top - 1]
    }

    function pop() {
        return this.dataStore[--this.top]
    }

    function clear() {
        this.top = 0
    }

    function length() {
        return this.top
    }

    // 3.测试 Stack 类的实现
    {
        console.log('新建一个栈')
        let s = new Stack()
        console.log('push a b c')

        s.push('a')
        s.push('b')
        s.push('c')
        console.log('栈实例', s, '栈实例 length:', s.length())
        console.log('栈实例', s, '栈实例 栈顶元素:', s.peek())
        // console.log('pop()')
        // let popped = s.pop()
        // console.log('栈实例', s, 'the popped element is:' + popped)
        // console.log('栈实例', s, '栈实例 栈顶元素:', s.peek())
        // console.log('push("d")')
        // s.push('d')
        // console.log('栈实例', s, '栈实例 栈顶元素:', s.peek())
        // console.log('clear()')
        // s.clear()
        // console.log('栈实例', s, '栈实例 length:', s.length())
        // console.log('push("e")')
        // s.push('e')
        // console.log('栈实例', s, '栈实例 栈顶元素:', s.peek())
    }
    // 4.使用 Stack 类
    // 4.1.数制间的相互转换(十进制 转 2~9进制数)
    {
        function mulBase(num, base) {
            let s = new Stack()
            do {
                s.push(num % base)
                num = Math.floor(num /= base)
            } while (num > 0)
            let converted = ""
            while (s.length() > 0) {
                converted += s.pop()
            }
            return converted
        }

        // 测试
        console.log('测试 十进制转二进制', '十进制8', '二进制:', mulBase(8, 2))
    }
    // 4.2 回文
    // 回文: 一个单词、短语或数字,从前往后和从后往前写都是一样的.
    // 使用栈判断一个单词是否是回文
    {
        // 原理:字符串完整压入栈内后,通过持续弹出栈中的每一个字母就可以得到一个新字符串,该字符串刚好与原来的字符串顺序相反.比较两个字符串,如果相等就是一个回文.
        function isPalindrome(word) {
            let s = new Stack()
            for (let i = 0; i < word.length; i++) {
                s.push(word[i])
            }
            let rWord = ""
            while (s.length() > 0) {
                rWord += s.pop()
            }
            if (word === rWord) {
                return true
            } else {
                return false
            }
        }

        // 测试
        let word = "hello"
        let word1 = 'abcdcba'
        console.log('hello是回文吗', isPalindrome(word), 'abcdcba是回文吗', isPalindrome(word1))
    }
    // 4.3递归演示
    // 递归学习,请阅读 使用 JavaScript 讲解递归工作原理的网页(http://bit.ly/lenDGE3)
    // 数字的阶乘
    {
        // 递归函数
        function factorial(n) {
            if (n === 0) {
                return 1
            } else {
                return n * factorial(n - 1)
            }
        }
        // 使用栈模拟递归过程
        function fact(n) {
            let s = new Stack()
            while(n>1){
                s.push(n--)
            }
            let product =1
            while(s.length()>0){
                product*=s.pop()
            }
            return product
        }
        console.log('递归函数,5的阶乘',factorial(5))
        console.log('栈模拟递归,5的阶乘',fact(5))

    }


</script>
</body>
</html>