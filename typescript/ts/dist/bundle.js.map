{"version":3,"file":"bundle.js","sources":["../node_modules/tslib/tslib.es6.js","../src/6.接口.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","// interface 描述对象的形状和结构，可以给数据增添类型， 而且方便复用\r\n\r\n// type的方式 通过别名来重新定义类型\r\n// interface 可以被类实现和继承，type没有功能\r\n// type 可以使用联合类型 interface 不能使用联合类型\r\n\r\n// 1)如何用接口描述对象类型，如果有联合类型 就使用type\r\ninterface IObj {\r\n  name: string;\r\n  age: number;\r\n}\r\n\r\n// type IObj = {name:string,age:number} | string // 支持联合类型\r\nconst getObj = (obj: IObj) => {\r\n  //    (obj as string).toLowerCase()\r\n};\r\n\r\n// 2) 描述函数类型\r\ninterface ISum {\r\n  (a: string, b: string): string;\r\n}\r\n// type ISum = (a:string,b:string) => string // 这里type更直观\r\nconst sum: ISum = (a, b) => {\r\n  return a + b;\r\n};\r\n\r\n// 3) 描述函数的属性 计数器的例子 每次调用函数 累加1\r\ninterface ICount {\r\n  (): number;\r\n  count: number;\r\n}\r\nconst fn: ICount = (() => {\r\n  // 函数返回函数 一般要标识函数的返回类型\r\n  return fn.count++;\r\n}) as ICount;\r\nfn.count = 0;\r\n\r\nconsole.log(fn());\r\nconsole.log(fn());\r\n\r\ninterface IEffect {\r\n  (): void;\r\n  id: number;\r\n}\r\n\r\nfunction effect(fn: Function) {\r\n  const reactiveEffect = createReactiveEffect(fn);\r\n  return reactiveEffect;\r\n}\r\nfunction createReactiveEffect(fn: Function): IEffect {\r\n  const effect: IEffect = function reactiveEffect() {};\r\n  effect.id = 1;\r\n  return effect;\r\n}\r\n\r\n// 4）接口的特性\r\n// interface IVegetables {\r\n//   color: string;\r\n//   taste: string;\r\n// }\r\n// 实际属性>接口属性\r\n// 1.直接断言，断言后可以直接使用(要保证接口中限制的数据必须要有)\r\n// const tomato:IVegetables = {\r\n//     color: 'red',\r\n//     taste: 'sweet',\r\n//     size: 'big'\r\n// } as IVegetables\r\n\r\n// 2.接口的合并 接口同名会合并，会改变原有的接口 比较危险\r\n// interface IVegetables {\r\n//     color: string;\r\n//     taste: string;\r\n//   }\r\n// interface IVegetables {\r\n//   size: string;\r\n// }\r\n// const tomato: IVegetables = {\r\n//   color: \"red\",\r\n//   taste: \"sweet\",\r\n//   size: \"big\",\r\n// };\r\n\r\n// 3.单独写一个tomato接口，继承蔬菜接口\r\n// interface IVegetables {\r\n//     color: string;\r\n//     taste: string;\r\n//   }\r\n// interface ITomato extends IVegetables { // 接口的继承 ts里的\r\n//     size:string\r\n// }\r\n// const tomato: ITomato = {\r\n//   color: \"red\",\r\n//   taste: \"sweet\",\r\n//   size: \"big\",\r\n// };\r\n\r\n// 4.可选属性 可以通过?来实现\r\n// interface IVegetables {\r\n//   color: string;\r\n//   taste: string;\r\n//   size?: string; // 函数的参数\r\n// }\r\n\r\n// const tomato: IVegetables = {\r\n//   color: \"red\",\r\n//   taste: \"sweet\",\r\n//   size: \"big\",\r\n// };\r\n// tomato.size // 好处 会有提示\r\n\r\n// 5.任意接口\r\ninterface IVegetables {\r\n  color: string;\r\n  taste: string;\r\n  [key: string]: any; // 任意接口 可多填  key写什么都行，一般写key\r\n}\r\n\r\nconst tomato: IVegetables = {\r\n  color: \"red\",\r\n  taste: \"sweet\",\r\n  size: \"big\",\r\n  a: 1,\r\n  1: 1,\r\n};\r\n\r\n// 6.可索引接口\r\ninterface IlikeArray {\r\n  [key: number]: any;\r\n}\r\nlet arr: IlikeArray = [1, 2, 3];\r\nlet arr1: IlikeArray = { 1: 1, 2: 2 };\r\n\r\n\r\n// 把一个对象赋值给一个接口，要满足接口中的所有属性\r\n// 如果多出来里的属性 可以采用 断言、可选、任意接口\r\n\r\n// 嵌套的情况\r\n// 接口中的类型 可以通过类型别名的方式拿出来，但是只能用[]\r\n// type MyType = {key:string,value:string}\r\n// interface XXX {\r\n//     n: MyType[]\r\n// }\r\n// interface IArr {\r\n//     arr: MyType[],\r\n//     a:XXX\r\n// }\r\n\r\n// type My = IArr['a']['n']\r\n\r\n// 7) 接口实现 接口可以被类来实现 , 接口中的方法都是抽象（没有具体实现）的\r\ninterface ISpeakable {\r\n  name: string,\r\n  // 用接口来形容类的时候  void 表示不关心返回值\r\n  speak(): void // 描述当前实例上的方法，或者原型的方法\r\n}\r\ninterface IChineseSpeakable {\r\n  speakChinese(): void\r\n}\r\nclass Speak implements ISpeakable, IChineseSpeakable { // 剋本身需要实现接口中的方法\r\n  speakChinese(): void {\r\n      throw new Error(\"Method not implemented.\");\r\n  }\r\n  name!: string\r\n  speak(): string { // 此方法是原型方法\r\n      return 'xxx'\r\n  }\r\n}\r\nlet s = new Speak()\r\n\r\n// 8.抽象类 不能被new, 可以被继承\r\nabstract class Animal { // 只有类被标记成abstract 属性在可以描述成abstract的\r\n  abstract name: string// 没有具体实现，需要子类实现\r\n  eat() {\r\n      console.log('eat')\r\n  }\r\n  abstract drink(): void\r\n}\r\nclass Cat extends Animal {\r\n  drink(): void {\r\n      console.log('Method not implemented')\r\n  }\r\n  name: string = 'a'\r\n}\r\n\r\n// 8.可以用接口来描述实例 \r\n\r\n// 单例模式\r\n// let instance: Person;\r\n// type IPerson = new (name:string)=>Person  描述的是构造函数类型   // clazz: IPerson\r\n// interface IPerson {\r\n//     new (name:string):Person\r\n// }\r\ninterface IPerson<T> {\r\n  new(name: string): T\r\n}\r\nfunction createInstance<T>(clazz: IPerson<T>, name: string) {\r\n  // if (instance) return instance;\r\n  return new clazz(name)\r\n}\r\nclass Person {\r\n  eat() { }\r\n  constructor(public name: string) { }\r\n}\r\nclass Dog {\r\n  drink() { }\r\n  constructor(public name: string) { }\r\n}\r\n\r\n// 泛型就是只有当使用的时候 才能确定类型， 通过参数传入类型\r\nlet r = createInstance<Person>(Person, '张三'); // 类可以充当类型，可以描述实例\r\nr.eat()\r\n\r\n\r\n// 接口的使用  接口特性 extends 、 implements （不能使用联合类型）\r\n// 别名可以使用联合类型 但是不能继承和实现\r\n\r\n\r\nexport {};\r\n"],"names":[],"mappings":";;;IAAA;IACA;AACA;IACA;IACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;IACA,IAAI,aAAa,GAAG,SAAS,CAAC,EAAE,CAAC,EAAE;IACnC,IAAI,aAAa,GAAG,MAAM,CAAC,cAAc;IACzC,SAAS,EAAE,SAAS,EAAE,EAAE,EAAE,YAAY,KAAK,IAAI,UAAU,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,SAAS,GAAG,CAAC,CAAC,EAAE,CAAC;IACpF,QAAQ,UAAU,CAAC,EAAE,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;IAC1G,IAAI,OAAO,aAAa,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC/B,CAAC,CAAC;AACF;IACO,SAAS,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE;IAChC,IAAI,IAAI,OAAO,CAAC,KAAK,UAAU,IAAI,CAAC,KAAK,IAAI;IAC7C,QAAQ,MAAM,IAAI,SAAS,CAAC,sBAAsB,GAAG,MAAM,CAAC,CAAC,CAAC,GAAG,+BAA+B,CAAC,CAAC;IAClG,IAAI,aAAa,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACxB,IAAI,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC,EAAE;IAC3C,IAAI,CAAC,CAAC,SAAS,GAAG,CAAC,KAAK,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,SAAS,GAAG,CAAC,CAAC,SAAS,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC;IACzF;;IC7BA;IA+BA,IAAM,EAAE,IAAY;;QAElB,OAAO,EAAE,CAAC,KAAK,EAAE,CAAC;IACpB,CAAC,CAAW,CAAC;IACb,EAAE,CAAC,KAAK,GAAG,CAAC,CAAC;IAEb,OAAO,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC;IAClB,OAAO,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC;IAmIlB;IACA;QAAA;SAMC;QAJC,oBAAG,GAAH;YACI,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;SACrB;QAEH,aAAC;IAAD,CAAC,IAAA;;QACiB,uBAAM;QAAxB;YAAA,qEAKC;YADC,UAAI,GAAW,GAAG,CAAA;;SACnB;QAJC,mBAAK,GAAL;YACI,OAAO,CAAC,GAAG,CAAC,wBAAwB,CAAC,CAAA;SACxC;QAEH,UAAC;IAAD,EALA,CAAkB,MAAM,GAKvB;IAaD,SAAS,cAAc,CAAI,KAAiB,EAAE,IAAY;;QAExD,OAAO,IAAI,KAAK,CAAC,IAAI,CAAC,CAAA;IACxB,CAAC;IACD;QAEE,gBAAmB,IAAY;YAAZ,SAAI,GAAJ,IAAI,CAAQ;SAAK;QADpC,oBAAG,GAAH,eAAS;QAEX,aAAC;IAAD,CAAC,IAAA;IAMD;IACA,IAAI,CAAC,GAAG,cAAc,CAAS,MAAM,EAAE,IAAI,CAAC,CAAC;IAC7C,CAAC,CAAC,GAAG,EAAE;;;;;;"}