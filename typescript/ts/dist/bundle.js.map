{"version":3,"file":"bundle.js","sources":["../src/6.接口.ts"],"sourcesContent":["// interface 描述对象的形状和结构，可以给数据增添类型， 而且方便复用\r\n\r\n// type的方式 通过别名来重新定义类型\r\n// interface 可以被类实现和继承，type没有功能\r\n// type 可以使用联合类型 interface 不能使用联合类型\r\n\r\n// 1)如何用接口描述对象类型，如果有联合类型 就使用type\r\ninterface IObj {\r\n  name: string;\r\n  age: number;\r\n}\r\n\r\n// type IObj = {name:string,age:number} | string // 支持联合类型\r\nconst getObj = (obj: IObj) => {\r\n  //    (obj as string).toLowerCase()\r\n};\r\n\r\n// 2) 描述函数类型\r\ninterface ISum {\r\n  (a: string, b: string): string;\r\n}\r\n// type ISum = (a:string,b:string) => string // 这里type更直观\r\nconst sum: ISum = (a, b) => {\r\n  return a + b;\r\n};\r\n\r\n// 3) 描述函数的属性 计数器的例子 每次调用函数 累加1\r\ninterface ICount {\r\n  (): number;\r\n  count: number;\r\n}\r\nconst fn: ICount = (() => {\r\n  // 函数返回函数 一般要标识函数的返回类型\r\n  return fn.count++;\r\n}) as ICount;\r\nfn.count = 0;\r\n\r\nconsole.log(fn());\r\nconsole.log(fn());\r\n\r\ninterface IEffect {\r\n  (): void;\r\n  id: number;\r\n}\r\n\r\nfunction effect(fn: Function) {\r\n  const reactiveEffect = createReactiveEffect(fn);\r\n  return reactiveEffect;\r\n}\r\nfunction createReactiveEffect(fn: Function): IEffect {\r\n  const effect: IEffect = function reactiveEffect() {};\r\n  effect.id = 1;\r\n  return effect;\r\n}\r\n\r\n// 4）接口的特性\r\n// interface IVegetables {\r\n//   color: string;\r\n//   taste: string;\r\n// }\r\n// 实际属性>接口属性\r\n// 1.直接断言，断言后可以直接使用(要保证接口中限制的数据必须要有)\r\n// const tomato:IVegetables = {\r\n//     color: 'red',\r\n//     taste: 'sweet',\r\n//     size: 'big'\r\n// } as IVegetables\r\n\r\n// 2.接口的合并 接口同名会合并，会改变原有的接口 比较危险\r\n// interface IVegetables {\r\n//     color: string;\r\n//     taste: string;\r\n//   }\r\n// interface IVegetables {\r\n//   size: string;\r\n// }\r\n// const tomato: IVegetables = {\r\n//   color: \"red\",\r\n//   taste: \"sweet\",\r\n//   size: \"big\",\r\n// };\r\n\r\n// 3.单独写一个tomato接口，继承蔬菜接口\r\n// interface IVegetables {\r\n//     color: string;\r\n//     taste: string;\r\n//   }\r\n// interface ITomato extends IVegetables { // 接口的继承 ts里的\r\n//     size:string\r\n// }\r\n// const tomato: ITomato = {\r\n//   color: \"red\",\r\n//   taste: \"sweet\",\r\n//   size: \"big\",\r\n// };\r\n\r\n// 4.可选属性 可以通过?来实现\r\n// interface IVegetables {\r\n//   color: string;\r\n//   taste: string;\r\n//   size?: string; // 函数的参数\r\n// }\r\n\r\n// const tomato: IVegetables = {\r\n//   color: \"red\",\r\n//   taste: \"sweet\",\r\n//   size: \"big\",\r\n// };\r\n// tomato.size // 好处 会有提示\r\n\r\n// 5.任意接口\r\ninterface IVegetables {\r\n  color: string;\r\n  taste: string;\r\n  [key: string]: any; // 任意接口 可多填  key写什么都行，一般写key\r\n}\r\n\r\nconst tomato: IVegetables = {\r\n  color: \"red\",\r\n  taste: \"sweet\",\r\n  size: \"big\",\r\n  a: 1,\r\n  1: 1,\r\n};\r\n\r\n// 6.可索引接口\r\ninterface IlikeArray {\r\n  [key: number]: any;\r\n}\r\nlet arr: IlikeArray = [1, 2, 3];\r\nlet arr1: IlikeArray = { 1: 1, 2: 2 };\r\n\r\n\r\n// 把一个对象赋值给一个接口，要满足接口中的所有属性\r\n// 如果多出来里的属性 可以采用 断言、可选、任意接口\r\n\r\n// 嵌套的情况\r\n// 接口中的类型 可以通过类型别名的方式拿出来，但是只能用[]\r\n// type MyType = {key:string,value:string}\r\n// interface XXX {\r\n//     n: MyType[]\r\n// }\r\n// interface IArr {\r\n//     arr: MyType[],\r\n//     a:XXX\r\n// }\r\n\r\n// type My = IArr['a']['n']\r\n\r\nexport {};\r\n"],"names":[],"mappings":";;;EAAA;EA+BA,IAAM,EAAE,IAAY;;MAElB,OAAO,EAAE,CAAC,KAAK,EAAE,CAAC;EACpB,CAAC,CAAW,CAAC;EACb,EAAE,CAAC,KAAK,GAAG,CAAC,CAAC;EAEb,OAAO,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC;EAClB,OAAO,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC;;;;;;"}