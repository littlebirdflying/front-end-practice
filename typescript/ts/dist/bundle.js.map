{"version":3,"file":"bundle.js","sources":["../src/2.联合类型.ts"],"sourcesContent":["// 联合类型 如果不进行初始化操作 必须给类型 否则都是any\r\nlet xxx; // any\r\nlet numOrStr: string | number;\r\n// 默认联合类型 在没有确认类型前 只能调用类型公共的方法\r\n// 在变量确认类型后 可以设置对应的方法\r\n// numOrStr.\r\n// numOrStr = 1\r\n// numOrStr.\r\n// numOrStr = 's'\r\n// numOrStr.\r\n\r\n// 如果赋值类型后，可以根据上下文自动推断对应类型的方法\r\n\r\n// 场景？ 在取值时也会遇到联合类型\r\n// numOrStr.\r\nconst ele: HTMLElement | null = document.getElementById(\"app\"); // const ele: HTMLElement | null\r\n\r\n// if (ele) {\r\n//     ele.innerHTML = 'abc'\r\n// }\r\n// ele && (ele.innerHTML = 'abc')\r\n// !非空断言 表示这个东西一定有值，告诉ts 按照我的想法来，如果后续出错我负责 ts特有\r\nele!.innerHTML = \"abc\";\r\n// as / <> 直接强转某个类型(强转要求必须联合类型中有才行)\r\nlet a: string | number | undefined;\r\n// 会被识别成jsx语法 <div class={}> <string>a 和jsx冲突 不建议使用\r\n// (<string>a).indexOf('a') // 强转后，方便提示\r\n// 强转的另一种写法\r\n// (a as string).indexOf('a') // 不会和jsx冲突\r\n// 双重断言 先转化成any 再转化成一个具体的类型，问题是会导致类型出问题\r\n(a as any) as boolean;\r\n\r\n// ? 号 等价于 a && a.xx && a.xx.xxx 链判断运算符 ?是js中就存在的\r\n// let a =1\r\n// a?.a // undefined\r\n// a?.a?.a // undefined a.a没值，直接返回undefined\r\n\r\n// || && | & ??\r\n\r\nfalse ?? true; // ?? 表示排除 null和undefined，如果是null和undefined则返回??后面的\r\n\r\n// 字面量类型 类型的内容是固定的 枚举\r\nlet type: \"a\" | \"b\" | \"c\" | \"d\" = \"b\";\r\n// 如果类型过于负责，希望复用，可以把类型单独提取出来\r\ntype IType = \"a\" | \"b\" | \"c\" | \"d\" // 类型别名\r\nlet type1: IType = 'a'\r\nlet type2: IType = 'b'\r\n\r\n\r\nexport {};\r\n"],"names":[],"mappings":";;;CAAA;CAGA;CACA;CACA;CACA;CACA;CACA;CACA;CAEA;CAEA;CACA;CACA,IAAM,GAAG,GAAuB,QAAQ,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;CAE/D;CACA;CACA;CACA;CACA;CACA,GAAI,CAAC,SAAS,GAAG,KAAK;;;;;;"}