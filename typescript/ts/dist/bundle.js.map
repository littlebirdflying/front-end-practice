{"version":3,"file":"bundle.js","sources":["../src/index.ts"],"sourcesContent":["// https://www.tslang.cn/docs/home.html\r\n// 1.基础类型\r\n// 最基本的类型 数字 字符串 布尔\r\n// 数字 字符串 布尔 数组 元组 any never void null undefined 枚举 11种\r\n// 所有类型都在冒号的后面，ts的核心一切都已安全为准\r\n// 什么时候可以不用类型，推导\r\n// number和Number的区别 js特性 装箱的概念 xxx.xxx\r\nlet num1: number = 1;\r\nlet num2: Number = 1; // 用来描述实例的 类也可以当做类型 这里1也是Number的实例\r\nlet num3: number = Number(1);\r\nlet num4: Number = new Number(1);\r\nlet str1: String = new String(\"tm\");\r\n\r\n// 最基本\r\nlet num: number = 1;\r\nlet str: string = \"tm\";\r\nlet bool: boolean = true;\r\n\r\n// 数组类型 数组的概念：一类类型的集合\r\nconst arr: number[] = []; // number组成的数组\r\nconst arr2: (number | string)[] = [\"a\", 1]; // | 并集的含义\r\nconst arr3: any[] = [\"\", 1, {}]; // 数组里放任何类型，不能类型推断，都是any了\r\nconst arr4: Array<boolean> = [true, false]; // 另一种定义数组的方式，泛型的方式\r\n\r\n// 元组 ts中自己实现的 内容固定 类型固定\r\nconst tuple: [string, boolean, number] = [\"a\", true, 1]; // 初始化 必须按照要求填入数据\r\n// 操作元组\r\nlet r = tuple.pop(); // pop的有可能是这四种类型 let r: string | number | boolean | undefined\r\ntuple.push(\"str\"); // 在放入时 可以放入元组中定义的类型\r\ntuple[2] = 100;\r\n// tuple[3] = 100 // 利用索引不能超出长度 Type '100' is not assignable to type 'undefined'.ts(2322)\r\n\r\n// 数据交换 会用到元素 结合泛型\r\n\r\n// 枚举类型 ts最终编译成js 是没有类型的，只是在开发时使用 一般大写(规范)\r\n// 普通枚举 异构枚举 常量枚举\r\n// 枚举支持反举，但仅限于索引，会根据上一个的值自动判断\r\n\r\n// 普通枚举\r\n// enum ROLE {\r\n//     USER, // 默认值为0\r\n//     ADMIN,\r\n//     MANAGER\r\n// }\r\n// console.log(ROLE.USER) // 0\r\n// console.log(ROLE[0]) // USER 支持反举(使用较少)\r\n\r\n// 异构枚举\r\n// enum ROLE {\r\n//     USER = 'USER',\r\n//     ADMIN = 5,\r\n//     MANAGER\r\n// }\r\n\r\n// 常量枚举  加上const后 不会生成一个对象，也不支持反举(更简洁)\r\nconst enum ROLE {\r\n  USER = \"USER\",\r\n  ADMIN = 5,\r\n  MANAGER,\r\n}\r\n\r\nconsole.log(ROLE.USER);\r\n\r\n// null undefined  \"是任何类型的子类型\"\r\n// 在严格模式下 undefined只能赋给undefined null只能赋给null\r\n\r\n// let name:number = undefined // \"strictNullChecks\": false,\r\nlet u: undefined = undefined;\r\nlet n: null = null;\r\n\r\n// never 从不 代码无法达到终点，无法执行到结尾  \"是任何类型的子类型\"\r\n// 出错、死循环、永远走不到的判断，3种情况，两种是自己标的，一种是走不到的逻辑\r\n\r\n// 永远走不到的判断\r\nfunction setVal(val: string) {\r\n  if (typeof val === \"string\") {\r\n  } else {\r\n    val; // 帮我们代码做完整校验 走不到else中 val就是never\r\n  }\r\n}\r\n\r\n// 出错\r\nfunction throwError(): never {  \r\n  throw new Error();\r\n}\r\n\r\n// let xx: string = throwError();\r\n\r\n// 死循环\r\nfunction whileTrue(): never {\r\n  while (true) {}\r\n}\r\n\r\n// void  表示函数的返回值 也可以描述变量 void的值只能赋予null和undefined\r\n// 严格模式下 不能把null 赋予给void类型(\"strictNullChecks\": false)\r\n\r\nfunction getVoid(): void {\r\n  // return undefined\r\n}\r\n\r\n// object\r\n// 后面泛型约束 会大量使用object类型\r\nfunction create(obj:object) {\r\n    \r\n}\r\ncreate({})\r\ncreate(function(){})\r\ncreate([])\r\n\r\n// Symbol BigInt js的类型 用的不多\r\nlet s1:symbol = Symbol(1)\r\nlet s2:symbol = Symbol(2)\r\nconsole.log(s1 === s2) // false es6语法无法编译成es5\r\n\r\nlet max = Number.MAX_SAFE_INTEGER\r\nlet r1:bigint = BigInt(max)\r\nconsole.log(max+1 === max+2) // true\r\nconsole.log(BigInt(max)+BigInt(1) === BigInt(max)+BigInt(2)) // false\r\n\r\nexport {}; // 防止模块间的数据共享类型\r\n"],"names":[],"mappings":";;;EAAA;EAwBA;EACA,IAAM,KAAK,GAA8B,CAAC,GAAG,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;EACxD;EACQ,KAAK,CAAC,GAAG,GAAG;EACpB,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;EAClB,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;EAgCf,OAAO,CAAC,GAAG,mBAAW,CAAC;EAgDvB;EACA,IAAI,EAAE,GAAU,MAAM,CAAC,CAAC,CAAC,CAAA;EACzB,IAAI,EAAE,GAAU,MAAM,CAAC,CAAC,CAAC,CAAA;EACzB,OAAO,CAAC,GAAG,CAAC,EAAE,KAAK,EAAE,CAAC,CAAA;EAEtB,IAAI,GAAG,GAAG,MAAM,CAAC,gBAAgB,CAAA;EACjB,MAAM,CAAC,GAAG,EAAC;EAC3B,OAAO,CAAC,GAAG,CAAC,GAAG,GAAC,CAAC,KAAK,GAAG,GAAC,CAAC,CAAC,CAAA;EAC5B,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,GAAC,MAAM,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,GAAG,CAAC,GAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAA;;;;;;"}